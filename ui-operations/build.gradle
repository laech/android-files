apply plugin: 'com.android.library'
apply plugin: 'com.neenbedankt.android-apt'
apply plugin: 'provided-base'

android {
    compileSdkVersion project.compileSdkVersion
    buildToolsVersion project.buildToolsVersion

    defaultConfig {
        minSdkVersion project.minSdkVersion
        targetSdkVersion project.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE'
    }

}

dependencies {

    compile project(':operations')
    compile project(':ui-base')

    apt 'com.google.auto.value:auto-value:1.1'
    provided 'com.google.auto.value:auto-value:1.1'
    provided 'javax.annotation:javax.annotation-api:1.2'

    androidTestCompile project(':testing')

    androidTestCompile 'org.mockito:mockito-core:1.10.19'
    androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
    androidTestCompile 'com.google.dexmaker:dexmaker-mockito:1.2'

    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-core:1.10.19'
    testCompile "org.robolectric:robolectric:3.0"

}

// Below is workaround copied from https://github.com/robolectric/robolectric/issues/1796

// This task discovers the manifest files for the .aars that we depend on and
// adds them to project.ext.manifestFiles for use in later tasks.
task discoverManifestFiles(dependsOn: 'prepareDebugDependencies') << {

    def aars = new File(project.buildDir.absolutePath + "/intermediates/exploded-aar")
    def manifestFiles = new ArrayList<File>()

    // Iterate through the exploded-aars directory, finding the manifests
    aars.eachFileRecurse(groovy.io.FileType.FILES) {
        if (it.name.endsWith('AndroidManifest.xml') && !it.absolutePath.contains('aapt')) {
            manifestFiles.add(it)
        }
    }

    project.ext.manifestFiles = manifestFiles;
}

// After gradle's done compiling the code, it'll run this to add some more tasks for us.
afterEvaluate { project ->

    // Debug and release get their own tasks
    android.libraryVariants.each { variant ->

        // TODO extract from our manifest?  Should be on the build variant
        def myPackageNamespace = "l.files.ui.operations"
        def myPackagePath = myPackageNamespace.replaceAll("\\.", "/")

        def processedPackages = new ArrayList<String>()

        // Task one of two that we're adding:  it depends on discovering manifest files
        // and on processing resources for this build variant.  It copies the merged R.java file
        // from our project's namespace (which contains the resource IDs included in our
        // dependencies) and drops it into each of our dependencies' namespaces.  This is to work
        // around limitations in robolectric.
        def copyRJavaTaskName = "copy${variant.name.capitalize()}RJavaForRobolectric"
        task(copyRJavaTaskName,
                dependsOn: ["process${variant.name.capitalize()}Resources", "discoverManifestFiles"]) << {

            // For each manifest file we discovered earlier, open it up an pull out the package
            project.ext.manifestFiles.each {
                def parsedManifestRoot = (new XmlParser()).parse(it.absolutePath)
                def targetPackageNamespace = parsedManifestRoot.@package

                // If it was already added, skip it
                if(!processedPackages.contains(targetPackageNamespace)){
                    processedPackages.add(targetPackageNamespace)
                } else {
                    println "WARNING:  Found two versions of $targetPackageNamespace; this could mess" +
                            " with your assets and resources"
                    // For some reason there are two versions of this dependency
                    // so skip additional iterations
                    return
                }

                def targetPackageNamespacePath = targetPackageNamespace.replaceAll("\\.", "/")

                // Copy R.java from our outputs into the namespace of each dependency
                // (and change the package line in the file, correspondingly)
                copy {
                    from "build/generated/source/r/${variant.name}/$myPackagePath"
                    include 'R.java'
                    into "src/test/java/$targetPackageNamespacePath"
                    filter { line -> line.contains("package ${myPackageNamespace};") ? "package ${targetPackageNamespace};" : line }
                }
            }
        }
        // Insert this new task into the task tree:  compiling unit tests depends on it.
        tasks.getByName("compile${variant.name.capitalize()}UnitTestJavaWithJavac") dependsOn copyRJavaTaskName


        // Second task we're adding:  copy lib assets into the place where robolectric expects them.
        // It depends on processing this variant's resources and on discovering manifest files.
        def copyAssetsTaskName = "copy${variant.name.capitalize()}AssetsForRobolectric"
        task(copyAssetsTaskName,
                dependsOn: ["process${variant.name.capitalize()}Resources",  "discoverManifestFiles"]) << {

            // For each manifest file we discovered, find that project's assets folder and copy it
            // to the same merged destination dir
            project.ext.manifestFiles.each {
                def manifestDirectory = it.parent

                def src = "${manifestDirectory}/assets"
                def dest = "build/intermediates/bundles/${variant.name}/assets"

                copy {
                    from src
                    include '**/*'
                    into dest
                }
            }
        }
        // Insert this new task into the task tree:  executing unit tests depends on it.
        tasks.getByName("test${variant.name.capitalize()}UnitTest") dependsOn copyAssetsTaskName
    }
}
