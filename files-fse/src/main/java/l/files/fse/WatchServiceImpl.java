package l.files.fse;

import android.os.FileObserver;

import com.google.common.base.Supplier;
import com.google.common.collect.SetMultimap;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

import l.files.io.Path;
import l.files.logging.Logger;
import l.files.os.ErrnoException;
import l.files.os.Stat;

import static android.os.FileObserver.ATTRIB;
import static android.os.FileObserver.CLOSE_WRITE;
import static android.os.FileObserver.CREATE;
import static android.os.FileObserver.DELETE;
import static android.os.FileObserver.DELETE_SELF;
import static android.os.FileObserver.MOVED_FROM;
import static android.os.FileObserver.MOVED_TO;
import static android.os.FileObserver.MOVE_SELF;
import static com.google.common.base.Objects.toStringHelper;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Multimaps.newSetMultimap;
import static com.google.common.collect.Multimaps.synchronizedSetMultimap;
import static com.google.common.collect.Sets.newHashSet;
import static l.files.os.Stat.S_ISDIR;

final class WatchServiceImpl extends WatchService
    implements StopSelfListener.Callback, WatchEvent.Listener {

  // TODO use different lock for different paths?
  // TODO should listeners be removed when a directory is deleted?

  private static final Logger logger = Logger.get(WatchServiceImpl.class);

  /*
   * Do not use MODIFY, use CLOSE_WRITE instead. Which is sufficient and avoids
   * being flooding by huge amount of MODIFY events generated by some system
   * "files" (e.g. /dev/log/main, /dev/android_adb etc).
   */
  private static final int MODIFICATION_MASK = ATTRIB
      | CREATE
      | DELETE
      | DELETE_SELF
      | CLOSE_WRITE
      | MOVE_SELF
      | MOVED_FROM
      | MOVED_TO;

  /**
   * These are the path being monitored, via {@link #monitor(Path)}.
   * <p/>
   * When a directory is being monitored, file observers are started for its
   * child directories (but child directories are not marked as monitored,
   * unless they are explicitly monitored via {@link #monitor(Path)}) as well to
   * monitored changes that would change the child directories status, such as
   * adding/removing files in the child directory, which will cause the child
   * directory's last modified timestamp to be changed.
   */
  private final Set<Path> monitored = newHashSet();

  /**
   * Observers operate on inodes, there could be multiple paths pointing to the
   * same inode, for example, hard links, file systems mounted on different
   * mount points (/sdcard, /storage/emulated/0, /storage/emulated/legacy,
   * /storage/sdcard0, they are all mount points of the same device).
   */
  private final List<EventObserver> observers = newArrayList();

  private final SetMultimap<Path, WatchEvent.Listener> listeners =
      synchronizedSetMultimap(newSetMultimap(
          new HashMap<Path, Collection<WatchEvent.Listener>>(),
          new Supplier<Set<WatchEvent.Listener>>() {
            @Override public Set<WatchEvent.Listener> get() {
              return new CopyOnWriteArraySet<>();
            }
          }
      ));

  @Override public void register(Path path, WatchEvent.Listener listener) {
    synchronized (this) {
      if (listeners.put(path, listener)) {
        monitor(path);
      }
    }
  }

  @Override public void unregister(Path path, WatchEvent.Listener listener) {
    synchronized (this) {
      if (listeners.remove(path, listener) &&
          listeners.get(path).isEmpty()) {
        unmonitor(path);
      }
    }
  }

  @Override void stopAll() {
    synchronized (this) {
      for (FileObserver observer : observers) {
        observer.stopWatching();
      }
      observers.clear();
      monitored.clear();
      listeners.clear();
    }
  }

  @Override boolean isMonitored(Path path) {
    synchronized (this) {
      return monitored.contains(path);
    }
  }

  @Override boolean hasObserver(Path path) {
    synchronized (this) {
      for (EventObserver observer : observers) {
        if (observer.hasPath(path)) {
          return true;
        }
      }
      return false;
    }
  }

  /**
   * This method checks the node in record against the given node for the path,
   * if they are different, that means the file represented by the path has been
   * deleted and recreated, but notification has yet to arrive, for example,
   * delete a file, create a directory in it's place and start monitoring on it,
   * so quickly that the file system event will be landed after the monitoring.
   * So here cleans up the current state and will handle the late events
   * appropriately in listener methods.
   */
  private void checkNode(Path path, Node node) {
    for (EventObserver observer : observers) {
      if (observer.hasPath(path)) {
        if (!observer.getNode().equals(node)) {
          observer.stopWatching();
          removeSubtree(observer);
        }
        return;
      }
    }
  }

  /**
   * Checks the observer who is monitoring on the given node, involves removing
   * any paths that no longer exists - these paths have been deleted/moved but
   * file system notifications are not arrived yet.
   */
  private EventObserver checkObserver(Node node) {
    EventObserver observer = findObserver(node);
    if (observer == null) {
      return null;
    }

    List<Path> removed = observer.removeNonExistPaths();
    monitored.removeAll(removed);

    if (stopAndRemoveIfNoPath(observer, observers)) {
      observer = null;
    }

    for (Path p : removed) {
      removeChildMonitors(p);
      removeChildObservers(p);
    }

    return observer;
  }

  private EventObserver findObserver(Node node) {
    for (EventObserver observer : observers) {
      if (observer.getNode().equals(node)) {
        return observer;
      }
    }
    return null;
  }

  private void monitor(Path path) {
    Node node;
    try {
      node = Node.from(stat(path.toString()));
    } catch (ErrnoException e) {
      throw new WatchException("Failed to stat " + path, e);
    }

    synchronized (this) {
      checkNode(path, node);
      if (!monitored.add(path)) {
        return;
      }
      startObserver(path, node);
    }
    startObserversForSubDirs(path);
  }

  private void unmonitor(Path parent) {
    synchronized (this) {
      if (!monitored.remove(parent)) {
        return;
      }

      listeners.removeAll(parent);

      Iterator<EventObserver> it = observers.iterator();
      while (it.hasNext()) {
        EventObserver observer = it.next();
        observer.removePath(parent);
        for (Path path : observer.copyPaths()) {
          if (parent.equals(path.parent()) && !monitored.contains(path)) {
            observer.removePath(path);
          }
        }
        stopAndRemoveIfNoPath(observer, it);
      }
    }
  }

  private void startObserversForSubDirs(Path parent) {
    String[] names = parent.toFile().list();
    if (names == null) {
      return;
    }

    for (String name : names) {
      Path path = parent.child(name);
      Stat stat;
      try {
        stat = stat(path.toString());
      } catch (ErrnoException e) {
        logger.warn(e, "Failed to stat %s", name);
        continue;
      }
      if (S_ISDIR(stat.mode)) {
        startObserver(path, Node.from(stat));
      }
    }
  }

  private void startObserver(Path path, Node node) {
    synchronized (this) {
      checkNode(path, node);
      EventObserver observer = checkObserver(node);
      if (observer == null) {
        observer = new EventObserver(path, node, MODIFICATION_MASK);
        observer.addListener(new StopSelfListener(observer, this, node, path));
        observer.startWatching();
        observers.add(observer);
      }
      observer.addPath(path);
      observer.addListener(new UpdateChildrenListener(path, this));
      if (path.parent() != null) {
        observer.addListener(new UpdateSelfListener(path, this));
      }
    }
  }

  @Override public void onObserverStopped(EventObserver observer) {
    logger.debug("Stopped observer %s", observer);
    removeSubtree(observer);
  }

  /**
   * When an observer is stopped due to the path being deleted/moved/invalid,
   * call this to stop observers that are monitoring on child paths, as they are
   * now no longer valid after the parent path being deleted/moved.
   */
  private void removeSubtree(EventObserver observer) {
    synchronized (this) {
      List<Path> removed = observer.removePaths();
      monitored.removeAll(removed);
      observers.remove(observer);
      for (Path path : removed) {
        removeChildMonitors(path);
        removeChildObservers(path);
      }
    }
  }

  private void removeChildMonitors(Path parent) {
    Iterator<Path> it = monitored.iterator();
    while (it.hasNext()) {
      Path path = it.next();
      if (path.startsWith(parent)) {
        it.remove();
      }
    }
  }

  private void removeChildObservers(Path parent) {
    Iterator<EventObserver> it = observers.iterator();
    while (it.hasNext()) {
      EventObserver observer = it.next();
      List<Path> removed = observer.removeChildPaths(parent);
      monitored.removeAll(removed);
      stopAndRemoveIfNoPath(observer, it);
    }
  }

  private Stat stat(String path) throws ErrnoException {
    // Use stat() instead of lstat() as stat()
    // lstat() returns the inode of the link
    // stat() returns the inode of the referenced file/directory
    return Stat.stat(path);
  }

  @Override public void onEvent(WatchEvent event) {
    logger.debug("%s", event);

    switch (event.kind()) {
      case CREATE:
        onCreate(event.path());
        break;
      case DELETE:
        onDelete(event.path());
        break;
    }

    Path path = event.path();
    for (WatchEvent.Listener listener : listeners.get(path)) {
      listener.onEvent(event);
    }

    Path parent = path.parent();
    if (parent != null) {
      for (WatchEvent.Listener listener : listeners.get(parent)) {
        listener.onEvent(event);
      }
    }
  }

  private void onCreate(Path path) {
    if (path.toFile().isDirectory() && isMonitored(path.parent())) {
      try {
        startObserver(path, Node.from(stat(path.toString())));
      } catch (ErrnoException e) {
        // Path no longer exists, permission etc, ignore and continue
        logger.warn(e, "Failed to stat %s", path);
      }
    }
  }

  private void onDelete(Path path) {
    if (!path.toFile().exists()) {
      synchronized (this) {
        removePath(path);
      }
    }
  }

  private void removePath(Path path) {
    monitored.remove(path);
    removeChildMonitors(path);
    removeChildObservers(path);
    Iterator<EventObserver> it = observers.iterator();
    while (it.hasNext()) {
      EventObserver observer = it.next();
      if (observer.removePath(path)) {
        stopAndRemoveIfNoPath(observer, it);
        break;
      }
    }
  }

  private boolean stopAndRemoveIfNoPath(
      EventObserver observer, Collection<? extends EventObserver> observers) {

    if (observer.getPathCount() == 0) {
      observer.stopWatching();
      observers.remove(observer);
      return true;
    }
    return false;
  }

  private boolean stopAndRemoveIfNoPath(
      EventObserver observer, Iterator<EventObserver> it) {

    if (observer.getPathCount() == 0) {
      observer.stopWatching();
      it.remove();
      return true;
    }
    return false;
  }

  @Override public String toString() {
    synchronized (this) {
      return toStringHelper(this)
          .add("monitors", monitored)
          .add("observers", observers)
          .add("listeners", listeners)
          .toString();
    }
  }
}
